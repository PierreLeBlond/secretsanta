package main

import (
    "fmt"
    "os"
    "bufio"
    "io/ioutil"
    "strings"
    "math/rand"
    "time"
    "sort"
)

func circuit(users map[string]User, s string) {


}

func check(e error) {
    if e != nil {
        panic(e)
    }
}

func remove(s []string, i int) []string {
    var t []string;
    for j, elem := range s {
        if (i != j) {
            t = append(t, elem);
        }
    }
    return t;
}

func updateGraph(users map[string]User, sources []string, targets []string, matches []Match) (bool, []Match) {

    // If all users have found a match, resolve positively
    if (len(users) == len(matches)) {
        return true, matches;
    }

    // fmt.Print(matches);
    // fmt.Print("\n\n");

    sort.Slice(sources, func(i, j int) bool {
        return len(users[sources[i]].always) + len(users[sources[i]].previous) >=
               len(users[sources[j]].always) + len(users[sources[j]].previous);
    });
    fmt.Print(sources);

    // From this user create a randomly sorted list of possible match
    for sourceIndex, source := range sources {
        r := rand.New(rand.NewSource(time.Now().Unix()))
        for _, targetIndex := range r.Perm(len(targets)) {
            target := targets[targetIndex];
            if (target != source && !users[source].always[target] && !users[source].previous[target]) {
                // fmt.Printf("Testing %v : %s ---> %s ( %v of %v)\n", len(matches), source, target, index, len(targets));
                // We found a possible match, let's see if we can further construct matches
                resolved, finalMatches := updateGraph(
                    users,
                    remove(sources, sourceIndex),
                    remove(targets, targetIndex),
                    append(matches, Match{source, target}));

                    if (resolved) {
                        return true, finalMatches
                    }
                }
            }
        }

        // fmt.Print("No matches found...\n");
    return false, nil;
}

func main() {

    if (len(os.Args) < 2) {
        fmt.Println("Error: Please provide ouput file name.");
        return;
    }

    fmt.Printf("Computing secret santa's list into %s...\n", os.Args[1]);

    // Retrieve users
    var users = make(map[string]User);
    var usersNames []string;
    f, err := os.Open("../data/user.txt");
    check(err);
    defer f.Close();

    usersScanner := bufio.NewScanner(f);
    for usersScanner.Scan() {
        var s = usersScanner.Text();
        usersNames = append(usersNames, s);
        g, err := ioutil.ReadFile("../data/" + s + ".txt");
        check(err);

        t := string(g);

        parts := strings.SplitN(t, "\n\n", 2);

        users[s] = User{s, make(map[string]bool), make(map[string]bool)};

        always := strings.Split(parts[0], "\n");
        for _, name := range always {
            users[s].always[name] = true;
        }

        previous := strings.Split(parts[1], "\n");
        for _, name := range previous {
            users[s].previous[name] = true;
        }
    }

    var matches []Match;
    sources := make([]string, len(usersNames));
    targets := make([]string, len(usersNames));

    copy(sources, usersNames);
    copy(targets, usersNames);

    // fmt.Print(sources);
    // fmt.Print("\n");
    // fmt.Print(targets);
    // fmt.Print("\n");
    // fmt.Print(matches);
    // fmt.Print("\n");

    resolved, finalMatches := updateGraph(users, sources, targets, matches);

    if !resolved {
        // fmt.Print("no solution...");
        // fmt.Print("\n");
        // Remove some previous as there is no solution right now
        //resolved, finalMatches = updateGraph(users, sources, targets, matches);
    }

    fmt.Print(resolved);
    fmt.Print(finalMatches);

}
